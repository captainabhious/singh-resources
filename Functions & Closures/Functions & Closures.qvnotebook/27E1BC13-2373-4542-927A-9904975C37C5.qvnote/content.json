{
  "title": "Closures",
  "cells": [
    {
      "type": "text",
      "data": "<h2>Closure Syntax</h2>"
    },
    {
      "type": "code",
      "language": "swift",
      "data": " { (parameters) -> returnType in\n    statements\n }"
    },
    {
      "type": "text",
      "data": "<h2>Definition &amp; Types</h2>"
    },
    {
      "type": "text",
      "data": "<font face=\"Arial Unicode MS\">Closures: self-contained blocks of functionality that can be passed around &amp; used in code</font><div><ul><li><font face=\"Arial Unicode MS\">global &amp; nested functions are special cases of closures</font></li></ul><div><font face=\"Arial Unicode MS\">3 Forms of Closures:</font></div></div><div><ol><li><font face=\"Arial Unicode MS\">Global Functions:&nbsp;<span style=\"color: rgb(75, 209, 86); background-color: rgb(0, 0, 0);\">closures that have a name &amp; don't capture any values</span></font></li><li><font face=\"Arial Unicode MS\">Nested Functions:&nbsp;<span style=\"color: rgb(75, 209, 86); background-color: rgb(0, 0, 0);\">closures that have a name &amp; can capture values from their enclosing func</span></font></li><li><font face=\"Arial Unicode MS\">Closure Expressions:&nbsp;<span style=\"color: rgb(75, 209, 86); background-color: rgb(0, 0, 0);\">unnamed closures written in lightweight syntax that can capture value from surrouding context</span></font></li></ol></div>"
    },
    {
      "type": "text",
      "data": "<h2>Functions vs. Closures (Key Differences)</h2>"
    },
    {
      "type": "text",
      "data": "Function:<div><ul><li>has a name</li><li>has ‘func’ keyword</li><li>no ‘in’ keyword</li></ul><div>Closure:</div></div><div><ul><li>no name</li><li>no ‘func’ keyword</li><li>has ‘in’ keyword</li></ul></div>"
    },
    {
      "type": "text",
      "data": "<h3>Defining &amp; Calling Functions vs. Closures</h3>"
    },
    {
      "type": "code",
      "language": "swift",
      "data": "// Function Definition\nfunc giveAFunc () {\n  // func body\n}"
    },
    {
      "type": "code",
      "language": "swift",
      "data": "// Closure Definition\nvar giveNoFunc = { () -> () in\n  // closure body\n}"
    },
    {
      "type": "text",
      "data": "<ul><li>closure is stored inside of a var so we can call it</li><li>closure itself starts w/ { and ends with }</li><li>call is identical</li></ul>"
    },
    {
      "type": "text",
      "data": "<h3>Transforming a Function -&gt; Closure</h3>"
    },
    {
      "type": "code",
      "language": "swift",
      "data": "// Example Func - soon to become closure\nfunc sayHello(name: String) -> String {\n    return \"Hello \\(name)\"\n}"
    },
    {
      "type": "text",
      "data": "<ol><li>Replace ‘func’ keyword AND funcName w/ brace ‘{‘</li><li>Replace the ‘{‘ after returnType w/ ‘in’ keyword</li></ol>"
    },
    {
      "type": "code",
      "language": "swift",
      "data": "// Transformed Closure\n{ (name: String) -> String in\n    return \"Hello \\(name)\"\n} // gives error\n\n// fix by assigning closure to a var & calling like a func\nvar sayHello = { (name: String) -> String in\n    return \"Hello \\(name)\"\n}\nsayHello(\"Abhi Singh\") // prints \"Hello Abhi Singh\""
    },
    {
      "type": "text",
      "data": "<h1>Closure Expressions</h1><div><ul><li><b style=\"color: rgb(221, 221, 221);\">closure</b><span style=\"color: rgb(221, 221, 221);\"> </span><b style=\"color: rgb(221, 221, 221);\">expressions</b><span style=\"color: rgb(221, 221, 221);\">: a manner of writing inline closures in a brief, focused, syntax</span><br></li></ul></div>"
    },
    {
      "type": "text",
      "data": "<h2><font face=\"Arial Unicode MS\"><span style=\"font-weight: normal;\">Example 1: Refining a Method [sorted(by:)]</span></font></h2><h3><font face=\"Arial Unicode MS\">a) The Sorted Method&nbsp;</font></h3><div><ul><li><span style=\"color: rgb(75, 209, 86); background-color: rgb(0, 0, 0);\"><font face=\"Arial Unicode MS\">upon sorting, method returns new array (same size, type) correctly sorted (og array not modified)</font></span></li><li><span style=\"color: rgb(75, 209, 86); background-color: rgb(0, 0, 0);\"><font face=\"Arial Unicode MS\">method takes 2 arguments of same type as array's contents &amp; returns Bool value stating whether 1st should appear before (T) or after (F) 2nd</font></span></li><ul><li><span style=\"color: rgb(75, 209, 86); background-color: rgb(0, 0, 0);\"><font face=\"Arial Unicode MS\">therefore, sorting closure needs to be a func of type (String, String) -&gt; Bool</font></span></li></ul></ul></div>"
    },
    {
      "type": "code",
      "language": "swift",
      "data": "let names = [\"Brian\", \"Shek\", \"Abhi\", \"John\"]"
    },
    {
      "type": "text",
      "data": "One Way to Provide Sorting Closure: write normal func of correct type &amp; pass it in as argument to sorted(by:) method"
    },
    {
      "type": "code",
      "language": "swift",
      "data": "func backward (_ s1: String, s2: String) -> Bool {\n    return s1 > s2\n}\n\nvar reversedNames = names.sorted(by: backward) // [S, J, B, A] - sorted lexiographically"
    },
    {
      "type": "text",
      "data": "<h3>b) Closure Expression Syntax</h3><div><ul><li>parameters in c.e.s. can be <b>in-out</b> parameters but can’t have default values</li><li><b>variadic</b> parameters can be used if named</li><li><b>tuples</b> can be used as parameter &amp; return types&nbsp;</li></ul></div>"
    },
    {
      "type": "text",
      "data": "Closure Expression Version of backward(_:_:) Function"
    },
    {
      "type": "code",
      "language": "swift",
      "data": "reversedNames = names.sorted(by: { (s1: String, s2: String) -> Bool in\n    return s1 > s2\n})"
    },
    {
      "type": "text",
      "data": "<ul><li>parameters &amp; return type written INSIDE {}</li><li>‘in’ introduces start of closure’s body</li><li>can even be written on a single line</li><li>notice how call to sorted(by:) remains same&nbsp;</li><ul><li>pair of parentheses surround entire argument; argument, however, is now <b>inline</b> <b>closure</b></li></ul></ul>"
    },
    {
      "type": "text",
      "data": "<h3>c) Inferring Type From Context</h3>"
    },
    {
      "type": "text",
      "data": ""
    },
    {
      "type": "text",
      "data": ""
    },
    {
      "type": "text",
      "data": ""
    },
    {
      "type": "text",
      "data": ""
    },
    {
      "type": "text",
      "data": ""
    },
    {
      "type": "text",
      "data": ""
    },
    {
      "type": "text",
      "data": ""
    }
  ]
}